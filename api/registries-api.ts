/* tslint:disable */
/* eslint-disable */
/**
 * Container Registry service
 * ## Overview Container Registry service enables IONOS clients to manage docker and OCI compliant registries for use by their managed Kubernetes clusters. Use a Container Registry to ensure you have a privately accessed registry to efficiently support image pulls. ## Changelog ### 1.1.0  - Added new endpoints for Repositories  - Added new endpoints for Artifacts  - Added new endpoints for Vulnerabilities  - Added registry vulnerabilityScanning feature 
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: support@cloud.ionos.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { ApiErrorResponse } from '../model';
// @ts-ignore
import { PatchRegistryInput } from '../model';
// @ts-ignore
import { PostRegistryInput } from '../model';
// @ts-ignore
import { PostRegistryOutput } from '../model';
// @ts-ignore
import { PutRegistryInput } from '../model';
// @ts-ignore
import { PutRegistryOutput } from '../model';
// @ts-ignore
import { RegistriesResponse } from '../model';
// @ts-ignore
import { RegistryResponse } from '../model';
/**
 * RegistriesApi - axios parameter creator
 * @export
 */
export const RegistriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete registry
         * @param {string} registryId The unique ID of the registry
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesDelete: async (registryId: string,  options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesDelete.');
            }
            const localVarPath = `/registries/{registryId}`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all information for a specific container registry
         * @summary Get a registry
         * @param {string} registryId The unique ID of the registry
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesFindById: async (registryId: string,  options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesFindById.');
            }
            const localVarPath = `/registries/{registryId}`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all managed container registries for your account
         * @summary List all container registries
         * @param {string} [filterName] The registry name to search for
         * @param {string} [limit] The maximum number of elements to return (used together with pagination.token for pagination)
         * @param {string} [paginationToken] An opaque token used to iterate the set of results (used together with limit for pagination)
         * @param {number} [maxResults] - Limits the number of results returned.
         * @param {Map<string,string>} [filters] - Filters query parameters limit results to those containing a matching value for a specific property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesGet: async (filterName?: string, limit?: string, paginationToken?: string,  maxResults?: number, filters?: Map<string, string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/registries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }

            if ((filterName === undefined) && (configuration !== undefined)) {
                filterName = configuration.getDefaultParamValue('filterName');
            }
            if (filterName !== undefined) {
                localVarQueryParameter['filter.name'] = filterName;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((paginationToken === undefined) && (configuration !== undefined)) {
                paginationToken = configuration.getDefaultParamValue('paginationToken');
            }
            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination.token'] = paginationToken;
            }

        if (maxResults !== undefined) {
            localVarQueryParameter['maxResults'] = maxResults;
        }
        if (filters !== undefined) {
            if(typeof(filters) === "object"){
                filters = new Map(Object.entries(filters))
            }
            filters.forEach((value: string, key: string) => {
                localVarQueryParameter["filter." + key] = value;
            });
        }

    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the properties of a registry - \"garbageCollectionSchedule\" time and days of the week for runs
         * @summary Update the properties of a registry
         * @param {string} registryId The unique ID of the registry
         * @param {PatchRegistryInput} patchRegistryInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesPatch: async (registryId: string, patchRegistryInput: PatchRegistryInput,  options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesPatch.');
            }
            if (patchRegistryInput === null || patchRegistryInput === undefined) {
                throw new RequiredError('patchRegistryInput','Required parameter patchRegistryInput was null or undefined when calling registriesPatch.');
            }
            const localVarPath = `/registries/{registryId}`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchRegistryInput !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchRegistryInput !== undefined ? patchRegistryInput : {})
                : (patchRegistryInput || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a registry to hold container images or OCI compliant artifacts - \"name\" must have passed validation - \"location\" must be one of the available location IDs - \"garbageCollectionSchedule\" time and days of the week for runs - \"features\": \"vulnerabilityScanning\" default is enabled
         * @summary Create container registry
         * @param {PostRegistryInput} postRegistryInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesPost: async (postRegistryInput: PostRegistryInput,  options: any = {}): Promise<RequestArgs> => {
            if (postRegistryInput === null || postRegistryInput === undefined) {
                throw new RequiredError('postRegistryInput','Required parameter postRegistryInput was null or undefined when calling registriesPost.');
            }
            const localVarPath = `/registries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postRegistryInput !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postRegistryInput !== undefined ? postRegistryInput : {})
                : (postRegistryInput || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create/replace a registry to hold container images or OCI compliant artifacts **On create** - \"name\" must have passed validation - \"location\" must be one of the available location IDs **On update** - \"name\" cannot be changed - \"location\" cannot be changed **On create or update** - \"garbageCollectionSchedule\": time and days of the week for runs 
         * @summary Create or replace a container registry
         * @param {string} registryId The unique ID of the registry
         * @param {PutRegistryInput} putRegistryInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesPut: async (registryId: string, putRegistryInput: PutRegistryInput,  options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesPut.');
            }
            if (putRegistryInput === null || putRegistryInput === undefined) {
                throw new RequiredError('putRegistryInput','Required parameter putRegistryInput was null or undefined when calling registriesPut.');
            }
            const localVarPath = `/registries/{registryId}`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof putRegistryInput !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(putRegistryInput !== undefined ? putRegistryInput : {})
                : (putRegistryInput || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistriesApi - functional programming interface
 * @export
 */
export const RegistriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete registry
         * @param {string} registryId The unique ID of the registry
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesDelete(registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await RegistriesApiAxiosParamCreator(configuration).registriesDelete(registryId, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Get all information for a specific container registry
         * @summary Get a registry
         * @param {string} registryId The unique ID of the registry
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesFindById(registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const axiosArgs = await RegistriesApiAxiosParamCreator(configuration).registriesFindById(registryId, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * List all managed container registries for your account
         * @summary List all container registries
         * @param {string} [filterName] The registry name to search for
         * @param {string} [limit] The maximum number of elements to return (used together with pagination.token for pagination)
         * @param {string} [paginationToken] An opaque token used to iterate the set of results (used together with limit for pagination)
         * @param {number} [maxResults] - Limits the number of results returned.
         * @param {Map<string,string>} [filters] - Filters query parameters limit results to those containing a matching value for a specific property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesGet(filterName?: string, limit?: string, paginationToken?: string, maxResults?: number, filters?: Map<string, string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistriesResponse>> {
            const axiosArgs = await RegistriesApiAxiosParamCreator(configuration).registriesGet(filterName, limit, paginationToken, maxResults, filters, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Update the properties of a registry - \"garbageCollectionSchedule\" time and days of the week for runs
         * @summary Update the properties of a registry
         * @param {string} registryId The unique ID of the registry
         * @param {PatchRegistryInput} patchRegistryInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesPatch(registryId: string, patchRegistryInput: PatchRegistryInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const axiosArgs = await RegistriesApiAxiosParamCreator(configuration).registriesPatch(registryId, patchRegistryInput, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Create a registry to hold container images or OCI compliant artifacts - \"name\" must have passed validation - \"location\" must be one of the available location IDs - \"garbageCollectionSchedule\" time and days of the week for runs - \"features\": \"vulnerabilityScanning\" default is enabled
         * @summary Create container registry
         * @param {PostRegistryInput} postRegistryInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesPost(postRegistryInput: PostRegistryInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostRegistryOutput>> {
            const axiosArgs = await RegistriesApiAxiosParamCreator(configuration).registriesPost(postRegistryInput, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Create/replace a registry to hold container images or OCI compliant artifacts **On create** - \"name\" must have passed validation - \"location\" must be one of the available location IDs **On update** - \"name\" cannot be changed - \"location\" cannot be changed **On create or update** - \"garbageCollectionSchedule\": time and days of the week for runs 
         * @summary Create or replace a container registry
         * @param {string} registryId The unique ID of the registry
         * @param {PutRegistryInput} putRegistryInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesPut(registryId: string, putRegistryInput: PutRegistryInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutRegistryOutput>> {
            const axiosArgs = await RegistriesApiAxiosParamCreator(configuration).registriesPut(registryId, putRegistryInput, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * RegistriesApi - factory interface
 * @export
 */
export const RegistriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete registry
         * @param {string} registryId The unique ID of the registry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesDelete(registryId: string, options?: any): AxiosPromise<void> {
            return RegistriesApiFp(configuration).registriesDelete(registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all information for a specific container registry
         * @summary Get a registry
         * @param {string} registryId The unique ID of the registry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesFindById(registryId: string, options?: any): AxiosPromise<RegistryResponse> {
            return RegistriesApiFp(configuration).registriesFindById(registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all managed container registries for your account
         * @summary List all container registries
         * @param {string} [filterName] The registry name to search for
         * @param {string} [limit] The maximum number of elements to return (used together with pagination.token for pagination)
         * @param {string} [paginationToken] An opaque token used to iterate the set of results (used together with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesGet(filterName?: string, limit?: string, paginationToken?: string, options?: any): AxiosPromise<RegistriesResponse> {
            return RegistriesApiFp(configuration).registriesGet(filterName, limit, paginationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the properties of a registry - \"garbageCollectionSchedule\" time and days of the week for runs
         * @summary Update the properties of a registry
         * @param {string} registryId The unique ID of the registry
         * @param {PatchRegistryInput} patchRegistryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesPatch(registryId: string, patchRegistryInput: PatchRegistryInput, options?: any): AxiosPromise<RegistryResponse> {
            return RegistriesApiFp(configuration).registriesPatch(registryId, patchRegistryInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a registry to hold container images or OCI compliant artifacts - \"name\" must have passed validation - \"location\" must be one of the available location IDs - \"garbageCollectionSchedule\" time and days of the week for runs - \"features\": \"vulnerabilityScanning\" default is enabled
         * @summary Create container registry
         * @param {PostRegistryInput} postRegistryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesPost(postRegistryInput: PostRegistryInput, options?: any): AxiosPromise<PostRegistryOutput> {
            return RegistriesApiFp(configuration).registriesPost(postRegistryInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create/replace a registry to hold container images or OCI compliant artifacts **On create** - \"name\" must have passed validation - \"location\" must be one of the available location IDs **On update** - \"name\" cannot be changed - \"location\" cannot be changed **On create or update** - \"garbageCollectionSchedule\": time and days of the week for runs 
         * @summary Create or replace a container registry
         * @param {string} registryId The unique ID of the registry
         * @param {PutRegistryInput} putRegistryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesPut(registryId: string, putRegistryInput: PutRegistryInput, options?: any): AxiosPromise<PutRegistryOutput> {
            return RegistriesApiFp(configuration).registriesPut(registryId, putRegistryInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for registriesDelete operation in RegistriesApi.
 * @export
 * @interface RegistriesApiRegistriesDeleteRequest
 */
export interface RegistriesApiRegistriesDeleteRequest {
    /**
     * The unique ID of the registry
     * @type {string}
     * @memberof RegistriesApiRegistriesDelete
     */
    readonly registryId: string
}

/**
 * Request parameters for registriesFindById operation in RegistriesApi.
 * @export
 * @interface RegistriesApiRegistriesFindByIdRequest
 */
export interface RegistriesApiRegistriesFindByIdRequest {
    /**
     * The unique ID of the registry
     * @type {string}
     * @memberof RegistriesApiRegistriesFindById
     */
    readonly registryId: string
}

/**
 * Request parameters for registriesGet operation in RegistriesApi.
 * @export
 * @interface RegistriesApiRegistriesGetRequest
 */
export interface RegistriesApiRegistriesGetRequest {
    /**
     * The registry name to search for
     * @type {string}
     * @memberof RegistriesApiRegistriesGet
     */
    readonly filterName?: string

    /**
     * The maximum number of elements to return (used together with pagination.token for pagination)
     * @type {string}
     * @memberof RegistriesApiRegistriesGet
     */
    readonly limit?: string

    /**
     * An opaque token used to iterate the set of results (used together with limit for pagination)
     * @type {string}
     * @memberof RegistriesApiRegistriesGet
     */
    readonly paginationToken?: string
    /**
     * limits the number of results returned
     * @type {number}
     * @memberof RegistriesApiRegistriesGet
     */
    readonly maxResults?: number
    /**
     * limits results to those containing a matching value for a specific property
     * @type {Map<string,string>}
     * @memberof RegistriesApiRegistriesGet
     */
    filters?: Map<string, string>
}

/**
 * Request parameters for registriesPatch operation in RegistriesApi.
 * @export
 * @interface RegistriesApiRegistriesPatchRequest
 */
export interface RegistriesApiRegistriesPatchRequest {
    /**
     * The unique ID of the registry
     * @type {string}
     * @memberof RegistriesApiRegistriesPatch
     */
    readonly registryId: string

    /**
     * 
     * @type {PatchRegistryInput}
     * @memberof RegistriesApiRegistriesPatch
     */
    readonly patchRegistryInput: PatchRegistryInput
}

/**
 * Request parameters for registriesPost operation in RegistriesApi.
 * @export
 * @interface RegistriesApiRegistriesPostRequest
 */
export interface RegistriesApiRegistriesPostRequest {
    /**
     * 
     * @type {PostRegistryInput}
     * @memberof RegistriesApiRegistriesPost
     */
    readonly postRegistryInput: PostRegistryInput
}

/**
 * Request parameters for registriesPut operation in RegistriesApi.
 * @export
 * @interface RegistriesApiRegistriesPutRequest
 */
export interface RegistriesApiRegistriesPutRequest {
    /**
     * The unique ID of the registry
     * @type {string}
     * @memberof RegistriesApiRegistriesPut
     */
    readonly registryId: string

    /**
     * 
     * @type {PutRegistryInput}
     * @memberof RegistriesApiRegistriesPut
     */
    readonly putRegistryInput: PutRegistryInput
}

/**
 * RegistriesApi - object-oriented interface
 * @export
 * @class RegistriesApi
 * @extends {BaseAPI}
 */
export class RegistriesApi extends BaseAPI {
    /**
     * 
     * @summary Delete registry
     * @param {RegistriesApiRegistriesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registriesDelete(requestParameters: RegistriesApiRegistriesDeleteRequest, options?: any) {
        return RegistriesApiFp(this.configuration).registriesDelete(requestParameters.registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all information for a specific container registry
     * @summary Get a registry
     * @param {RegistriesApiRegistriesFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registriesFindById(requestParameters: RegistriesApiRegistriesFindByIdRequest, options?: any) {
        return RegistriesApiFp(this.configuration).registriesFindById(requestParameters.registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all managed container registries for your account
     * @summary List all container registries
     * @param {RegistriesApiRegistriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registriesGet(requestParameters: RegistriesApiRegistriesGetRequest = {}, options?: any) {
        return RegistriesApiFp(this.configuration).registriesGet(requestParameters.filterName, requestParameters.limit, requestParameters.paginationToken, requestParameters.maxResults, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the properties of a registry - \"garbageCollectionSchedule\" time and days of the week for runs
     * @summary Update the properties of a registry
     * @param {RegistriesApiRegistriesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registriesPatch(requestParameters: RegistriesApiRegistriesPatchRequest, options?: any) {
        return RegistriesApiFp(this.configuration).registriesPatch(requestParameters.registryId, requestParameters.patchRegistryInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a registry to hold container images or OCI compliant artifacts - \"name\" must have passed validation - \"location\" must be one of the available location IDs - \"garbageCollectionSchedule\" time and days of the week for runs - \"features\": \"vulnerabilityScanning\" default is enabled
     * @summary Create container registry
     * @param {RegistriesApiRegistriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registriesPost(requestParameters: RegistriesApiRegistriesPostRequest, options?: any) {
        return RegistriesApiFp(this.configuration).registriesPost(requestParameters.postRegistryInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create/replace a registry to hold container images or OCI compliant artifacts **On create** - \"name\" must have passed validation - \"location\" must be one of the available location IDs **On update** - \"name\" cannot be changed - \"location\" cannot be changed **On create or update** - \"garbageCollectionSchedule\": time and days of the week for runs 
     * @summary Create or replace a container registry
     * @param {RegistriesApiRegistriesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registriesPut(requestParameters: RegistriesApiRegistriesPutRequest, options?: any) {
        return RegistriesApiFp(this.configuration).registriesPut(requestParameters.registryId, requestParameters.putRegistryInput, options).then((request) => request(this.axios, this.basePath));
    }
}
