/* tslint:disable */
/* eslint-disable */
/**
 * Container Registry service
 * Container Registry service enables IONOS clients to manage docker and OCI compliant registries for use by their managed Kubernetes clusters. Use a Container Registry to ensure you have a privately accessed registry to efficiently support image pulls.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@cloud.ionos.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { ApiErrorResponse } from '../model';
// @ts-ignore
import { PatchTokenInput } from '../model';
// @ts-ignore
import { PostTokenInput } from '../model';
// @ts-ignore
import { PostTokenOutput } from '../model';
// @ts-ignore
import { PutTokenInput } from '../model';
// @ts-ignore
import { PutTokenOutput } from '../model';
// @ts-ignore
import { TokenResponse } from '../model';
// @ts-ignore
import { TokensResponse } from '../model';
/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete token
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensDelete: async (registryId: string, tokenId: string,  options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesTokensDelete.');
            }
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling registriesTokensDelete.');
            }
            const localVarPath = `/registries/{registryId}/tokens/{tokenId}`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all information for a specific token used to access a container registry
         * @summary Get token information
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensFindById: async (registryId: string, tokenId: string,  options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesTokensFindById.');
            }
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling registriesTokensFindById.');
            }
            const localVarPath = `/registries/{registryId}/tokens/{tokenId}`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all tokens for the container registry
         * @param {string} registryId The unique ID of the registry
         * @param {string} [offset] The first element (from the complete list of the elements) to include in the response (used together with limit for pagination)
         * @param {string} [limit] The maximum number of elements to return (used together with offset for pagination)
         * @param {string} [orderBy] - Sorts the results alphanumerically in ascending order based on the specified property.
         * @param {number} [maxResults] - Limits the number of results returned.
         * @param {Map<string,string>} [filters] - Filters query parameters limit results to those containing a matching value for a specific property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensGet: async (registryId: string, offset?: string, limit?: string,  orderBy?: string, maxResults?: number, filters?: Map<string, string>, options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesTokensGet.');
            }
            const localVarPath = `/registries/{registryId}/tokens`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

        if (orderBy !== undefined) {
            localVarQueryParameter['orderBy'] = orderBy;
        }
        if (maxResults !== undefined) {
            localVarQueryParameter['maxResults'] = maxResults;
        }
        if (filters !== undefined) {
            if(typeof(filters) === "object"){
                filters = new Map(Object.entries(filters))
            }
            filters.forEach((value: string, key: string) => {
                localVarQueryParameter["filter." + key] = value;
            });
        }

    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update token properties, for example: - change status to \'enabled\' or \'disabled\' - change expiry date
         * @summary Update token
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         * @param {PatchTokenInput} patchTokenInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensPatch: async (registryId: string, tokenId: string, patchTokenInput: PatchTokenInput,  options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesTokensPatch.');
            }
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling registriesTokensPatch.');
            }
            if (patchTokenInput === null || patchTokenInput === undefined) {
                throw new RequiredError('patchTokenInput','Required parameter patchTokenInput was null or undefined when calling registriesTokensPatch.');
            }
            const localVarPath = `/registries/{registryId}/tokens/{tokenId}`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchTokenInput !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchTokenInput !== undefined ? patchTokenInput : {})
                : (patchTokenInput || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a token - password is only available once in the POST response
         * @summary Create token
         * @param {string} registryId The unique ID of the registry
         * @param {PostTokenInput} postTokenInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensPost: async (registryId: string, postTokenInput: PostTokenInput,  options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesTokensPost.');
            }
            if (postTokenInput === null || postTokenInput === undefined) {
                throw new RequiredError('postTokenInput','Required parameter postTokenInput was null or undefined when calling registriesTokensPost.');
            }
            const localVarPath = `/registries/{registryId}/tokens`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postTokenInput !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postTokenInput !== undefined ? postTokenInput : {})
                : (postTokenInput || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create/replace a token - password is only available once in the create response - \"name\" cannot be changed
         * @summary Create or replace token
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         * @param {PutTokenInput} putTokenInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensPut: async (registryId: string, tokenId: string, putTokenInput: PutTokenInput,  options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesTokensPut.');
            }
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling registriesTokensPut.');
            }
            if (putTokenInput === null || putTokenInput === undefined) {
                throw new RequiredError('putTokenInput','Required parameter putTokenInput was null or undefined when calling registriesTokensPut.');
            }
            const localVarPath = `/registries/{registryId}/tokens/{tokenId}`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof putTokenInput !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(putTokenInput !== undefined ? putTokenInput : {})
                : (putTokenInput || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete token
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesTokensDelete(registryId: string, tokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await TokensApiAxiosParamCreator(configuration).registriesTokensDelete(registryId, tokenId, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Gets all information for a specific token used to access a container registry
         * @summary Get token information
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesTokensFindById(registryId: string, tokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const axiosArgs = await TokensApiAxiosParamCreator(configuration).registriesTokensFindById(registryId, tokenId, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * 
         * @summary List all tokens for the container registry
         * @param {string} registryId The unique ID of the registry
         * @param {string} [offset] The first element (from the complete list of the elements) to include in the response (used together with limit for pagination)
         * @param {string} [limit] The maximum number of elements to return (used together with offset for pagination)
         * @param {string} [orderBy] - Sorts the results alphanumerically in ascending order based on the specified property.
         * @param {number} [maxResults] - Limits the number of results returned.
         * @param {Map<string,string>} [filters] - Filters query parameters limit results to those containing a matching value for a specific property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesTokensGet(registryId: string, offset?: string, limit?: string, orderBy?: string, maxResults?: number, filters?: Map<string, string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const axiosArgs = await TokensApiAxiosParamCreator(configuration).registriesTokensGet(registryId, offset, limit, orderBy, maxResults, filters, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Update token properties, for example: - change status to \'enabled\' or \'disabled\' - change expiry date
         * @summary Update token
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         * @param {PatchTokenInput} patchTokenInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesTokensPatch(registryId: string, tokenId: string, patchTokenInput: PatchTokenInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const axiosArgs = await TokensApiAxiosParamCreator(configuration).registriesTokensPatch(registryId, tokenId, patchTokenInput, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Create a token - password is only available once in the POST response
         * @summary Create token
         * @param {string} registryId The unique ID of the registry
         * @param {PostTokenInput} postTokenInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesTokensPost(registryId: string, postTokenInput: PostTokenInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostTokenOutput>> {
            const axiosArgs = await TokensApiAxiosParamCreator(configuration).registriesTokensPost(registryId, postTokenInput, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Create/replace a token - password is only available once in the create response - \"name\" cannot be changed
         * @summary Create or replace token
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         * @param {PutTokenInput} putTokenInput 
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesTokensPut(registryId: string, tokenId: string, putTokenInput: PutTokenInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutTokenOutput>> {
            const axiosArgs = await TokensApiAxiosParamCreator(configuration).registriesTokensPut(registryId, tokenId, putTokenInput, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete token
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensDelete(registryId: string, tokenId: string, options?: any): AxiosPromise<void> {
            return TokensApiFp(configuration).registriesTokensDelete(registryId, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all information for a specific token used to access a container registry
         * @summary Get token information
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensFindById(registryId: string, tokenId: string, options?: any): AxiosPromise<TokenResponse> {
            return TokensApiFp(configuration).registriesTokensFindById(registryId, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all tokens for the container registry
         * @param {string} registryId The unique ID of the registry
         * @param {string} [offset] The first element (from the complete list of the elements) to include in the response (used together with limit for pagination)
         * @param {string} [limit] The maximum number of elements to return (used together with offset for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensGet(registryId: string, offset?: string, limit?: string, options?: any): AxiosPromise<TokensResponse> {
            return TokensApiFp(configuration).registriesTokensGet(registryId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update token properties, for example: - change status to \'enabled\' or \'disabled\' - change expiry date
         * @summary Update token
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         * @param {PatchTokenInput} patchTokenInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensPatch(registryId: string, tokenId: string, patchTokenInput: PatchTokenInput, options?: any): AxiosPromise<TokenResponse> {
            return TokensApiFp(configuration).registriesTokensPatch(registryId, tokenId, patchTokenInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a token - password is only available once in the POST response
         * @summary Create token
         * @param {string} registryId The unique ID of the registry
         * @param {PostTokenInput} postTokenInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensPost(registryId: string, postTokenInput: PostTokenInput, options?: any): AxiosPromise<PostTokenOutput> {
            return TokensApiFp(configuration).registriesTokensPost(registryId, postTokenInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create/replace a token - password is only available once in the create response - \"name\" cannot be changed
         * @summary Create or replace token
         * @param {string} registryId The unique ID of the registry
         * @param {string} tokenId The unique ID of the token
         * @param {PutTokenInput} putTokenInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesTokensPut(registryId: string, tokenId: string, putTokenInput: PutTokenInput, options?: any): AxiosPromise<PutTokenOutput> {
            return TokensApiFp(configuration).registriesTokensPut(registryId, tokenId, putTokenInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for registriesTokensDelete operation in TokensApi.
 * @export
 * @interface TokensApiRegistriesTokensDeleteRequest
 */
export interface TokensApiRegistriesTokensDeleteRequest {
    /**
     * The unique ID of the registry
     * @type {string}
     * @memberof TokensApiRegistriesTokensDelete
     */
    readonly registryId: string

    /**
     * The unique ID of the token
     * @type {string}
     * @memberof TokensApiRegistriesTokensDelete
     */
    readonly tokenId: string
}

/**
 * Request parameters for registriesTokensFindById operation in TokensApi.
 * @export
 * @interface TokensApiRegistriesTokensFindByIdRequest
 */
export interface TokensApiRegistriesTokensFindByIdRequest {
    /**
     * The unique ID of the registry
     * @type {string}
     * @memberof TokensApiRegistriesTokensFindById
     */
    readonly registryId: string

    /**
     * The unique ID of the token
     * @type {string}
     * @memberof TokensApiRegistriesTokensFindById
     */
    readonly tokenId: string
}

/**
 * Request parameters for registriesTokensGet operation in TokensApi.
 * @export
 * @interface TokensApiRegistriesTokensGetRequest
 */
export interface TokensApiRegistriesTokensGetRequest {
    /**
     * The unique ID of the registry
     * @type {string}
     * @memberof TokensApiRegistriesTokensGet
     */
    readonly registryId: string

    /**
     * The first element (from the complete list of the elements) to include in the response (used together with limit for pagination)
     * @type {string}
     * @memberof TokensApiRegistriesTokensGet
     */
    readonly offset?: string

    /**
     * The maximum number of elements to return (used together with offset for pagination)
     * @type {string}
     * @memberof TokensApiRegistriesTokensGet
     */
    readonly limit?: string
    /**
     * sorts the results alphanumerically in ascending order based on the specified property
     * @type {string}
     * @memberof TokensApiRegistriesTokensGet
     */
    readonly orderBy?: string
    /**
     * limits the number of results returned
     * @type {number}
     * @memberof TokensApiRegistriesTokensGet
     */
    readonly maxResults?: number
    /**
     * limits results to those containing a matching value for a specific property
     * @type {Map<string,string>}
     * @memberof TokensApiRegistriesTokensGet
     */
    filters?: Map<string, string>
}

/**
 * Request parameters for registriesTokensPatch operation in TokensApi.
 * @export
 * @interface TokensApiRegistriesTokensPatchRequest
 */
export interface TokensApiRegistriesTokensPatchRequest {
    /**
     * The unique ID of the registry
     * @type {string}
     * @memberof TokensApiRegistriesTokensPatch
     */
    readonly registryId: string

    /**
     * The unique ID of the token
     * @type {string}
     * @memberof TokensApiRegistriesTokensPatch
     */
    readonly tokenId: string

    /**
     * 
     * @type {PatchTokenInput}
     * @memberof TokensApiRegistriesTokensPatch
     */
    readonly patchTokenInput: PatchTokenInput
}

/**
 * Request parameters for registriesTokensPost operation in TokensApi.
 * @export
 * @interface TokensApiRegistriesTokensPostRequest
 */
export interface TokensApiRegistriesTokensPostRequest {
    /**
     * The unique ID of the registry
     * @type {string}
     * @memberof TokensApiRegistriesTokensPost
     */
    readonly registryId: string

    /**
     * 
     * @type {PostTokenInput}
     * @memberof TokensApiRegistriesTokensPost
     */
    readonly postTokenInput: PostTokenInput
}

/**
 * Request parameters for registriesTokensPut operation in TokensApi.
 * @export
 * @interface TokensApiRegistriesTokensPutRequest
 */
export interface TokensApiRegistriesTokensPutRequest {
    /**
     * The unique ID of the registry
     * @type {string}
     * @memberof TokensApiRegistriesTokensPut
     */
    readonly registryId: string

    /**
     * The unique ID of the token
     * @type {string}
     * @memberof TokensApiRegistriesTokensPut
     */
    readonly tokenId: string

    /**
     * 
     * @type {PutTokenInput}
     * @memberof TokensApiRegistriesTokensPut
     */
    readonly putTokenInput: PutTokenInput
}

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * 
     * @summary Delete token
     * @param {TokensApiRegistriesTokensDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public registriesTokensDelete(requestParameters: TokensApiRegistriesTokensDeleteRequest, options?: any) {
        return TokensApiFp(this.configuration).registriesTokensDelete(requestParameters.registryId, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all information for a specific token used to access a container registry
     * @summary Get token information
     * @param {TokensApiRegistriesTokensFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public registriesTokensFindById(requestParameters: TokensApiRegistriesTokensFindByIdRequest, options?: any) {
        return TokensApiFp(this.configuration).registriesTokensFindById(requestParameters.registryId, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all tokens for the container registry
     * @param {TokensApiRegistriesTokensGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public registriesTokensGet(requestParameters: TokensApiRegistriesTokensGetRequest, options?: any) {
        return TokensApiFp(this.configuration).registriesTokensGet(requestParameters.registryId, requestParameters.offset, requestParameters.limit, requestParameters.orderBy, requestParameters.maxResults, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update token properties, for example: - change status to \'enabled\' or \'disabled\' - change expiry date
     * @summary Update token
     * @param {TokensApiRegistriesTokensPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public registriesTokensPatch(requestParameters: TokensApiRegistriesTokensPatchRequest, options?: any) {
        return TokensApiFp(this.configuration).registriesTokensPatch(requestParameters.registryId, requestParameters.tokenId, requestParameters.patchTokenInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a token - password is only available once in the POST response
     * @summary Create token
     * @param {TokensApiRegistriesTokensPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public registriesTokensPost(requestParameters: TokensApiRegistriesTokensPostRequest, options?: any) {
        return TokensApiFp(this.configuration).registriesTokensPost(requestParameters.registryId, requestParameters.postTokenInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create/replace a token - password is only available once in the create response - \"name\" cannot be changed
     * @summary Create or replace token
     * @param {TokensApiRegistriesTokensPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public registriesTokensPut(requestParameters: TokensApiRegistriesTokensPutRequest, options?: any) {
        return TokensApiFp(this.configuration).registriesTokensPut(requestParameters.registryId, requestParameters.tokenId, requestParameters.putTokenInput, options).then((request) => request(this.axios, this.basePath));
    }
}
