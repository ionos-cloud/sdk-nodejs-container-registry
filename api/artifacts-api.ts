/* tslint:disable */
/* eslint-disable */
/**
 * Container Registry service
 * ## Overview Container Registry service enables IONOS clients to manage docker and OCI compliant registries for use by their managed Kubernetes clusters. Use a Container Registry to ensure you have a privately accessed registry to efficiently support image pulls. ## Changelog ### 1.1.0  - Added new endpoints for Repositories  - Added new endpoints for Artifacts  - Added new endpoints for Vulnerabilities  - Added registry vulnerabilityScanning feature 
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: support@cloud.ionos.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { ArtifactRead } from '../model';
// @ts-ignore
import { ArtifactReadList } from '../model';
// @ts-ignore
import { ArtifactVulnerabilityReadList } from '../model';
// @ts-ignore
import { RegistryArtifactsReadList } from '../model';
/**
 * ArtifactsApi - axios parameter creator
 * @export
 */
export const ArtifactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables retrieving all Artifacts using pagination and optional filters. 
         * @summary Retrieve all Artifacts by Registry
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {number} [offset] The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
         * @param {number} [limit] The maximum number of elements to return. Use together with offset for pagination.
         * @param {string} [filterVulnerabilityId] Filter resources by vulnerabilityId.
         * @param {'-pullCount' | '-pushCount' | '-lastPush' | '-lastPull' | '-lastScan' | '-vulnTotalCount' | '-vulnFixableCount' | 'pullCount' | 'pushCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'vulnTotalCount' | 'vulnFixableCount'} [orderBy] The field to order the results by. If not provided, the results will be ordered by the default field.
         * @param {number} [maxResults] - Limits the number of results returned.
         * @param {Map<string,string>} [filters] - Filters query parameters limit results to those containing a matching value for a specific property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesArtifactsGet: async (registryId: string, offset?: number, limit?: number, filterVulnerabilityId?: string, orderBy?: '-pullCount' | '-pushCount' | '-lastPush' | '-lastPull' | '-lastScan' | '-vulnTotalCount' | '-vulnFixableCount' | 'pullCount' | 'pushCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'vulnTotalCount' | 'vulnFixableCount',  maxResults?: number, filters?: Map<string, string>, options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesArtifactsGet.');
            }
            const localVarPath = `/registries/{registryId}/artifacts`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((filterVulnerabilityId === undefined) && (configuration !== undefined)) {
                filterVulnerabilityId = configuration.getDefaultParamValue('filterVulnerabilityId');
            }
            if (filterVulnerabilityId !== undefined) {
                localVarQueryParameter['filter.vulnerabilityId'] = filterVulnerabilityId;
            }

            if ((orderBy === undefined) && (configuration !== undefined)) {
                orderBy = configuration.getDefaultParamValue('orderBy');
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

        if (maxResults !== undefined) {
            localVarQueryParameter['maxResults'] = maxResults;
        }
        if (filters !== undefined) {
            if(typeof(filters) === "object"){
                filters = new Map(Object.entries(filters))
            }
            filters.forEach((value: string, key: string) => {
                localVarQueryParameter["filter." + key] = value;
            });
        }

    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artifact by Digest.
         * @summary Retrieve Artifact
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {string} repositoryName The Name of the Repository.
         * @param {string} digest The Digest of the Artifact that should be retrieved.
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRepositoriesArtifactsFindByDigest: async (registryId: string, repositoryName: string, digest: string,  options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesRepositoriesArtifactsFindByDigest.');
            }
            if (repositoryName === null || repositoryName === undefined) {
                throw new RequiredError('repositoryName','Required parameter repositoryName was null or undefined when calling registriesRepositoriesArtifactsFindByDigest.');
            }
            if (digest === null || digest === undefined) {
                throw new RequiredError('digest','Required parameter digest was null or undefined when calling registriesRepositoriesArtifactsFindByDigest.');
            }
            const localVarPath = `/registries/{registryId}/repositories/{repositoryName}/artifacts/{digest}`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryName"}}`, encodeURIComponent(String(repositoryName)))
                .replace(`{${"digest"}}`, encodeURIComponent(String(digest)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables retrieving all Artifacts using pagination and optional filters. 
         * @summary Retrieve all Artifacts by Repository
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {string} repositoryName The Name of the Repository.
         * @param {number} [offset] The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
         * @param {number} [limit] The maximum number of elements to return. Use together with offset for pagination.
         * @param {'-lastPush' | '-lastPull' | '-lastScan' | '-pullCount' | '-pushCount' | '-vulnMaxSeverity' | '-vulnTotalScore' | '-vulnTotalCount' | '-vulnFixableCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'pullCount' | 'pushCount' | 'vulnMaxSeverity' | 'vulnTotalScore' | 'vulnTotalCount' | 'vulnFixableCount'} [orderBy] The field to order the results by. If not provided, the results will be ordered by the default field.
         * @param {number} [maxResults] - Limits the number of results returned.
         * @param {Map<string,string>} [filters] - Filters query parameters limit results to those containing a matching value for a specific property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRepositoriesArtifactsGet: async (registryId: string, repositoryName: string, offset?: number, limit?: number, orderBy?: '-lastPush' | '-lastPull' | '-lastScan' | '-pullCount' | '-pushCount' | '-vulnMaxSeverity' | '-vulnTotalScore' | '-vulnTotalCount' | '-vulnFixableCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'pullCount' | 'pushCount' | 'vulnMaxSeverity' | 'vulnTotalScore' | 'vulnTotalCount' | 'vulnFixableCount',  maxResults?: number, filters?: Map<string, string>, options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesRepositoriesArtifactsGet.');
            }
            if (repositoryName === null || repositoryName === undefined) {
                throw new RequiredError('repositoryName','Required parameter repositoryName was null or undefined when calling registriesRepositoriesArtifactsGet.');
            }
            const localVarPath = `/registries/{registryId}/repositories/{repositoryName}/artifacts`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryName"}}`, encodeURIComponent(String(repositoryName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((orderBy === undefined) && (configuration !== undefined)) {
                orderBy = configuration.getDefaultParamValue('orderBy');
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

        if (maxResults !== undefined) {
            localVarQueryParameter['maxResults'] = maxResults;
        }
        if (filters !== undefined) {
            if(typeof(filters) === "object"){
                filters = new Map(Object.entries(filters))
            }
            filters.forEach((value: string, key: string) => {
                localVarQueryParameter["filter." + key] = value;
            });
        }

    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables retrieving all Vulnerabilities using pagination and optional filters. 
         * @summary Retrieve all Vulnerabilities
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {string} repositoryName The Name of the Repository.
         * @param {string} digest The Digest of the Artifact.
         * @param {number} [offset] The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
         * @param {number} [limit] The maximum number of elements to return. Use together with offset for pagination.
         * @param {string} [filterSeverity] Filter resources by vulnerability severity.
         * @param {boolean} [filterFixable] Filter resources by fixable (i.e. remediation action is available)
         * @param {'-score' | '-severity' | '-publishedAt' | '-updatedAt' | '-fixable' | 'score' | 'severity' | 'publishedAt' | 'updatedAt' | 'fixable'} [orderBy] The field to order the results by. If not provided, the results will be ordered by the default field.
         * @param {number} [maxResults] - Limits the number of results returned.
         * @param {Map<string,string>} [filters] - Filters query parameters limit results to those containing a matching value for a specific property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRepositoriesArtifactsVulnerabilitiesGet: async (registryId: string, repositoryName: string, digest: string, offset?: number, limit?: number, filterSeverity?: string, filterFixable?: boolean, orderBy?: '-score' | '-severity' | '-publishedAt' | '-updatedAt' | '-fixable' | 'score' | 'severity' | 'publishedAt' | 'updatedAt' | 'fixable',  maxResults?: number, filters?: Map<string, string>, options: any = {}): Promise<RequestArgs> => {
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling registriesRepositoriesArtifactsVulnerabilitiesGet.');
            }
            if (repositoryName === null || repositoryName === undefined) {
                throw new RequiredError('repositoryName','Required parameter repositoryName was null or undefined when calling registriesRepositoriesArtifactsVulnerabilitiesGet.');
            }
            if (digest === null || digest === undefined) {
                throw new RequiredError('digest','Required parameter digest was null or undefined when calling registriesRepositoriesArtifactsVulnerabilitiesGet.');
            }
            const localVarPath = `/registries/{registryId}/repositories/{repositoryName}/artifacts/{digest}/vulnerabilities`
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryName"}}`, encodeURIComponent(String(repositoryName)))
                .replace(`{${"digest"}}`, encodeURIComponent(String(digest)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((filterSeverity === undefined) && (configuration !== undefined)) {
                filterSeverity = configuration.getDefaultParamValue('filterSeverity');
            }
            if (filterSeverity !== undefined) {
                localVarQueryParameter['filter.severity'] = filterSeverity;
            }

            if ((filterFixable === undefined) && (configuration !== undefined)) {
                filterFixable = configuration.getDefaultParamValue('filterFixable');
            }
            if (filterFixable !== undefined) {
                localVarQueryParameter['filter.fixable'] = filterFixable;
            }

            if ((orderBy === undefined) && (configuration !== undefined)) {
                orderBy = configuration.getDefaultParamValue('orderBy');
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

        if (maxResults !== undefined) {
            localVarQueryParameter['maxResults'] = maxResults;
        }
        if (filters !== undefined) {
            if(typeof(filters) === "object"){
                filters = new Map(Object.entries(filters))
            }
            filters.forEach((value: string, key: string) => {
                localVarQueryParameter["filter." + key] = value;
            });
        }

    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsApi - functional programming interface
 * @export
 */
export const ArtifactsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint enables retrieving all Artifacts using pagination and optional filters. 
         * @summary Retrieve all Artifacts by Registry
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {number} [offset] The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
         * @param {number} [limit] The maximum number of elements to return. Use together with offset for pagination.
         * @param {string} [filterVulnerabilityId] Filter resources by vulnerabilityId.
         * @param {'-pullCount' | '-pushCount' | '-lastPush' | '-lastPull' | '-lastScan' | '-vulnTotalCount' | '-vulnFixableCount' | 'pullCount' | 'pushCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'vulnTotalCount' | 'vulnFixableCount'} [orderBy] The field to order the results by. If not provided, the results will be ordered by the default field.
         * @param {number} [maxResults] - Limits the number of results returned.
         * @param {Map<string,string>} [filters] - Filters query parameters limit results to those containing a matching value for a specific property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesArtifactsGet(registryId: string, offset?: number, limit?: number, filterVulnerabilityId?: string, orderBy?: '-pullCount' | '-pushCount' | '-lastPush' | '-lastPull' | '-lastScan' | '-vulnTotalCount' | '-vulnFixableCount' | 'pullCount' | 'pushCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'vulnTotalCount' | 'vulnFixableCount', maxResults?: number, filters?: Map<string, string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryArtifactsReadList>> {
            const axiosArgs = await ArtifactsApiAxiosParamCreator(configuration).registriesArtifactsGet(registryId, offset, limit, filterVulnerabilityId, orderBy, maxResults, filters, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Returns the Artifact by Digest.
         * @summary Retrieve Artifact
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {string} repositoryName The Name of the Repository.
         * @param {string} digest The Digest of the Artifact that should be retrieved.
         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesRepositoriesArtifactsFindByDigest(registryId: string, repositoryName: string, digest: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactRead>> {
            const axiosArgs = await ArtifactsApiAxiosParamCreator(configuration).registriesRepositoriesArtifactsFindByDigest(registryId, repositoryName, digest, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This endpoint enables retrieving all Artifacts using pagination and optional filters. 
         * @summary Retrieve all Artifacts by Repository
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {string} repositoryName The Name of the Repository.
         * @param {number} [offset] The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
         * @param {number} [limit] The maximum number of elements to return. Use together with offset for pagination.
         * @param {'-lastPush' | '-lastPull' | '-lastScan' | '-pullCount' | '-pushCount' | '-vulnMaxSeverity' | '-vulnTotalScore' | '-vulnTotalCount' | '-vulnFixableCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'pullCount' | 'pushCount' | 'vulnMaxSeverity' | 'vulnTotalScore' | 'vulnTotalCount' | 'vulnFixableCount'} [orderBy] The field to order the results by. If not provided, the results will be ordered by the default field.
         * @param {number} [maxResults] - Limits the number of results returned.
         * @param {Map<string,string>} [filters] - Filters query parameters limit results to those containing a matching value for a specific property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesRepositoriesArtifactsGet(registryId: string, repositoryName: string, offset?: number, limit?: number, orderBy?: '-lastPush' | '-lastPull' | '-lastScan' | '-pullCount' | '-pushCount' | '-vulnMaxSeverity' | '-vulnTotalScore' | '-vulnTotalCount' | '-vulnFixableCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'pullCount' | 'pushCount' | 'vulnMaxSeverity' | 'vulnTotalScore' | 'vulnTotalCount' | 'vulnFixableCount', maxResults?: number, filters?: Map<string, string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactReadList>> {
            const axiosArgs = await ArtifactsApiAxiosParamCreator(configuration).registriesRepositoriesArtifactsGet(registryId, repositoryName, offset, limit, orderBy, maxResults, filters, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This endpoint enables retrieving all Vulnerabilities using pagination and optional filters. 
         * @summary Retrieve all Vulnerabilities
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {string} repositoryName The Name of the Repository.
         * @param {string} digest The Digest of the Artifact.
         * @param {number} [offset] The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
         * @param {number} [limit] The maximum number of elements to return. Use together with offset for pagination.
         * @param {string} [filterSeverity] Filter resources by vulnerability severity.
         * @param {boolean} [filterFixable] Filter resources by fixable (i.e. remediation action is available)
         * @param {'-score' | '-severity' | '-publishedAt' | '-updatedAt' | '-fixable' | 'score' | 'severity' | 'publishedAt' | 'updatedAt' | 'fixable'} [orderBy] The field to order the results by. If not provided, the results will be ordered by the default field.
         * @param {number} [maxResults] - Limits the number of results returned.
         * @param {Map<string,string>} [filters] - Filters query parameters limit results to those containing a matching value for a specific property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesRepositoriesArtifactsVulnerabilitiesGet(registryId: string, repositoryName: string, digest: string, offset?: number, limit?: number, filterSeverity?: string, filterFixable?: boolean, orderBy?: '-score' | '-severity' | '-publishedAt' | '-updatedAt' | '-fixable' | 'score' | 'severity' | 'publishedAt' | 'updatedAt' | 'fixable', maxResults?: number, filters?: Map<string, string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactVulnerabilityReadList>> {
            const axiosArgs = await ArtifactsApiAxiosParamCreator(configuration).registriesRepositoriesArtifactsVulnerabilitiesGet(registryId, repositoryName, digest, offset, limit, filterSeverity, filterFixable, orderBy, maxResults, filters, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * ArtifactsApi - factory interface
 * @export
 */
export const ArtifactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This endpoint enables retrieving all Artifacts using pagination and optional filters. 
         * @summary Retrieve all Artifacts by Registry
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {number} [offset] The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
         * @param {number} [limit] The maximum number of elements to return. Use together with offset for pagination.
         * @param {string} [filterVulnerabilityId] Filter resources by vulnerabilityId.
         * @param {'-pullCount' | '-pushCount' | '-lastPush' | '-lastPull' | '-lastScan' | '-vulnTotalCount' | '-vulnFixableCount' | 'pullCount' | 'pushCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'vulnTotalCount' | 'vulnFixableCount'} [orderBy] The field to order the results by. If not provided, the results will be ordered by the default field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesArtifactsGet(registryId: string, offset?: number, limit?: number, filterVulnerabilityId?: string, orderBy?: '-pullCount' | '-pushCount' | '-lastPush' | '-lastPull' | '-lastScan' | '-vulnTotalCount' | '-vulnFixableCount' | 'pullCount' | 'pushCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'vulnTotalCount' | 'vulnFixableCount', options?: any): AxiosPromise<RegistryArtifactsReadList> {
            return ArtifactsApiFp(configuration).registriesArtifactsGet(registryId, offset, limit, filterVulnerabilityId, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artifact by Digest.
         * @summary Retrieve Artifact
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {string} repositoryName The Name of the Repository.
         * @param {string} digest The Digest of the Artifact that should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRepositoriesArtifactsFindByDigest(registryId: string, repositoryName: string, digest: string, options?: any): AxiosPromise<ArtifactRead> {
            return ArtifactsApiFp(configuration).registriesRepositoriesArtifactsFindByDigest(registryId, repositoryName, digest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables retrieving all Artifacts using pagination and optional filters. 
         * @summary Retrieve all Artifacts by Repository
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {string} repositoryName The Name of the Repository.
         * @param {number} [offset] The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
         * @param {number} [limit] The maximum number of elements to return. Use together with offset for pagination.
         * @param {'-lastPush' | '-lastPull' | '-lastScan' | '-pullCount' | '-pushCount' | '-vulnMaxSeverity' | '-vulnTotalScore' | '-vulnTotalCount' | '-vulnFixableCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'pullCount' | 'pushCount' | 'vulnMaxSeverity' | 'vulnTotalScore' | 'vulnTotalCount' | 'vulnFixableCount'} [orderBy] The field to order the results by. If not provided, the results will be ordered by the default field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRepositoriesArtifactsGet(registryId: string, repositoryName: string, offset?: number, limit?: number, orderBy?: '-lastPush' | '-lastPull' | '-lastScan' | '-pullCount' | '-pushCount' | '-vulnMaxSeverity' | '-vulnTotalScore' | '-vulnTotalCount' | '-vulnFixableCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'pullCount' | 'pushCount' | 'vulnMaxSeverity' | 'vulnTotalScore' | 'vulnTotalCount' | 'vulnFixableCount', options?: any): AxiosPromise<ArtifactReadList> {
            return ArtifactsApiFp(configuration).registriesRepositoriesArtifactsGet(registryId, repositoryName, offset, limit, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables retrieving all Vulnerabilities using pagination and optional filters. 
         * @summary Retrieve all Vulnerabilities
         * @param {string} registryId The ID (UUID) of the Registry.
         * @param {string} repositoryName The Name of the Repository.
         * @param {string} digest The Digest of the Artifact.
         * @param {number} [offset] The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
         * @param {number} [limit] The maximum number of elements to return. Use together with offset for pagination.
         * @param {string} [filterSeverity] Filter resources by vulnerability severity.
         * @param {boolean} [filterFixable] Filter resources by fixable (i.e. remediation action is available)
         * @param {'-score' | '-severity' | '-publishedAt' | '-updatedAt' | '-fixable' | 'score' | 'severity' | 'publishedAt' | 'updatedAt' | 'fixable'} [orderBy] The field to order the results by. If not provided, the results will be ordered by the default field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRepositoriesArtifactsVulnerabilitiesGet(registryId: string, repositoryName: string, digest: string, offset?: number, limit?: number, filterSeverity?: string, filterFixable?: boolean, orderBy?: '-score' | '-severity' | '-publishedAt' | '-updatedAt' | '-fixable' | 'score' | 'severity' | 'publishedAt' | 'updatedAt' | 'fixable', options?: any): AxiosPromise<ArtifactVulnerabilityReadList> {
            return ArtifactsApiFp(configuration).registriesRepositoriesArtifactsVulnerabilitiesGet(registryId, repositoryName, digest, offset, limit, filterSeverity, filterFixable, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for registriesArtifactsGet operation in ArtifactsApi.
 * @export
 * @interface ArtifactsApiRegistriesArtifactsGetRequest
 */
export interface ArtifactsApiRegistriesArtifactsGetRequest {
    /**
     * The ID (UUID) of the Registry.
     * @type {string}
     * @memberof ArtifactsApiRegistriesArtifactsGet
     */
    readonly registryId: string

    /**
     * The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
     * @type {number}
     * @memberof ArtifactsApiRegistriesArtifactsGet
     */
    readonly offset?: number

    /**
     * The maximum number of elements to return. Use together with offset for pagination.
     * @type {number}
     * @memberof ArtifactsApiRegistriesArtifactsGet
     */
    readonly limit?: number

    /**
     * Filter resources by vulnerabilityId.
     * @type {string}
     * @memberof ArtifactsApiRegistriesArtifactsGet
     */
    readonly filterVulnerabilityId?: string

    /**
     * The field to order the results by. If not provided, the results will be ordered by the default field.
     * @type {'-pullCount' | '-pushCount' | '-lastPush' | '-lastPull' | '-lastScan' | '-vulnTotalCount' | '-vulnFixableCount' | 'pullCount' | 'pushCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'vulnTotalCount' | 'vulnFixableCount'}
     * @memberof ArtifactsApiRegistriesArtifactsGet
     */
    readonly orderBy?: '-pullCount' | '-pushCount' | '-lastPush' | '-lastPull' | '-lastScan' | '-vulnTotalCount' | '-vulnFixableCount' | 'pullCount' | 'pushCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'vulnTotalCount' | 'vulnFixableCount'
    /**
     * limits the number of results returned
     * @type {number}
     * @memberof ArtifactsApiRegistriesArtifactsGet
     */
    readonly maxResults?: number
    /**
     * limits results to those containing a matching value for a specific property
     * @type {Map<string,string>}
     * @memberof ArtifactsApiRegistriesArtifactsGet
     */
    filters?: Map<string, string>
}

/**
 * Request parameters for registriesRepositoriesArtifactsFindByDigest operation in ArtifactsApi.
 * @export
 * @interface ArtifactsApiRegistriesRepositoriesArtifactsFindByDigestRequest
 */
export interface ArtifactsApiRegistriesRepositoriesArtifactsFindByDigestRequest {
    /**
     * The ID (UUID) of the Registry.
     * @type {string}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsFindByDigest
     */
    readonly registryId: string

    /**
     * The Name of the Repository.
     * @type {string}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsFindByDigest
     */
    readonly repositoryName: string

    /**
     * The Digest of the Artifact that should be retrieved.
     * @type {string}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsFindByDigest
     */
    readonly digest: string
}

/**
 * Request parameters for registriesRepositoriesArtifactsGet operation in ArtifactsApi.
 * @export
 * @interface ArtifactsApiRegistriesRepositoriesArtifactsGetRequest
 */
export interface ArtifactsApiRegistriesRepositoriesArtifactsGetRequest {
    /**
     * The ID (UUID) of the Registry.
     * @type {string}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsGet
     */
    readonly registryId: string

    /**
     * The Name of the Repository.
     * @type {string}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsGet
     */
    readonly repositoryName: string

    /**
     * The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
     * @type {number}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsGet
     */
    readonly offset?: number

    /**
     * The maximum number of elements to return. Use together with offset for pagination.
     * @type {number}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsGet
     */
    readonly limit?: number

    /**
     * The field to order the results by. If not provided, the results will be ordered by the default field.
     * @type {'-lastPush' | '-lastPull' | '-lastScan' | '-pullCount' | '-pushCount' | '-vulnMaxSeverity' | '-vulnTotalScore' | '-vulnTotalCount' | '-vulnFixableCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'pullCount' | 'pushCount' | 'vulnMaxSeverity' | 'vulnTotalScore' | 'vulnTotalCount' | 'vulnFixableCount'}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsGet
     */
    readonly orderBy?: '-lastPush' | '-lastPull' | '-lastScan' | '-pullCount' | '-pushCount' | '-vulnMaxSeverity' | '-vulnTotalScore' | '-vulnTotalCount' | '-vulnFixableCount' | 'lastPush' | 'lastPull' | 'lastScan' | 'pullCount' | 'pushCount' | 'vulnMaxSeverity' | 'vulnTotalScore' | 'vulnTotalCount' | 'vulnFixableCount'
    /**
     * limits the number of results returned
     * @type {number}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsGet
     */
    readonly maxResults?: number
    /**
     * limits results to those containing a matching value for a specific property
     * @type {Map<string,string>}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsGet
     */
    filters?: Map<string, string>
}

/**
 * Request parameters for registriesRepositoriesArtifactsVulnerabilitiesGet operation in ArtifactsApi.
 * @export
 * @interface ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGetRequest
 */
export interface ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGetRequest {
    /**
     * The ID (UUID) of the Registry.
     * @type {string}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGet
     */
    readonly registryId: string

    /**
     * The Name of the Repository.
     * @type {string}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGet
     */
    readonly repositoryName: string

    /**
     * The Digest of the Artifact.
     * @type {string}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGet
     */
    readonly digest: string

    /**
     * The first element (of the total list of elements) to include in the response. Use together with limit for pagination.
     * @type {number}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGet
     */
    readonly offset?: number

    /**
     * The maximum number of elements to return. Use together with offset for pagination.
     * @type {number}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGet
     */
    readonly limit?: number

    /**
     * Filter resources by vulnerability severity.
     * @type {string}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGet
     */
    readonly filterSeverity?: string

    /**
     * Filter resources by fixable (i.e. remediation action is available)
     * @type {boolean}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGet
     */
    readonly filterFixable?: boolean

    /**
     * The field to order the results by. If not provided, the results will be ordered by the default field.
     * @type {'-score' | '-severity' | '-publishedAt' | '-updatedAt' | '-fixable' | 'score' | 'severity' | 'publishedAt' | 'updatedAt' | 'fixable'}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGet
     */
    readonly orderBy?: '-score' | '-severity' | '-publishedAt' | '-updatedAt' | '-fixable' | 'score' | 'severity' | 'publishedAt' | 'updatedAt' | 'fixable'
    /**
     * limits the number of results returned
     * @type {number}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGet
     */
    readonly maxResults?: number
    /**
     * limits results to those containing a matching value for a specific property
     * @type {Map<string,string>}
     * @memberof ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGet
     */
    filters?: Map<string, string>
}

/**
 * ArtifactsApi - object-oriented interface
 * @export
 * @class ArtifactsApi
 * @extends {BaseAPI}
 */
export class ArtifactsApi extends BaseAPI {
    /**
     * This endpoint enables retrieving all Artifacts using pagination and optional filters. 
     * @summary Retrieve all Artifacts by Registry
     * @param {ArtifactsApiRegistriesArtifactsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public registriesArtifactsGet(requestParameters: ArtifactsApiRegistriesArtifactsGetRequest, options?: any) {
        return ArtifactsApiFp(this.configuration).registriesArtifactsGet(requestParameters.registryId, requestParameters.offset, requestParameters.limit, requestParameters.filterVulnerabilityId, requestParameters.orderBy, requestParameters.maxResults, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artifact by Digest.
     * @summary Retrieve Artifact
     * @param {ArtifactsApiRegistriesRepositoriesArtifactsFindByDigestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public registriesRepositoriesArtifactsFindByDigest(requestParameters: ArtifactsApiRegistriesRepositoriesArtifactsFindByDigestRequest, options?: any) {
        return ArtifactsApiFp(this.configuration).registriesRepositoriesArtifactsFindByDigest(requestParameters.registryId, requestParameters.repositoryName, requestParameters.digest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables retrieving all Artifacts using pagination and optional filters. 
     * @summary Retrieve all Artifacts by Repository
     * @param {ArtifactsApiRegistriesRepositoriesArtifactsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public registriesRepositoriesArtifactsGet(requestParameters: ArtifactsApiRegistriesRepositoriesArtifactsGetRequest, options?: any) {
        return ArtifactsApiFp(this.configuration).registriesRepositoriesArtifactsGet(requestParameters.registryId, requestParameters.repositoryName, requestParameters.offset, requestParameters.limit, requestParameters.orderBy, requestParameters.maxResults, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables retrieving all Vulnerabilities using pagination and optional filters. 
     * @summary Retrieve all Vulnerabilities
     * @param {ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public registriesRepositoriesArtifactsVulnerabilitiesGet(requestParameters: ArtifactsApiRegistriesRepositoriesArtifactsVulnerabilitiesGetRequest, options?: any) {
        return ArtifactsApiFp(this.configuration).registriesRepositoriesArtifactsVulnerabilitiesGet(requestParameters.registryId, requestParameters.repositoryName, requestParameters.digest, requestParameters.offset, requestParameters.limit, requestParameters.filterSeverity, requestParameters.filterFixable, requestParameters.orderBy, requestParameters.maxResults, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }
}
